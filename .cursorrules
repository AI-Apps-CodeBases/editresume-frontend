# Cursor Rules for EditResume Frontend

## Regression Prevention Rules

### Before Making Changes
1. **Always search for existing implementations** before creating new code
2. **Identify all files that use the code** you're modifying using grep/codebase_search
3. **Check for related features** that might be affected by your changes
4. **Review the architecture document** (`docs/architecture.md`) to understand layering rules

### When Adding New Features
1. **Never modify shared components** (`src/components/Shared/`) without checking all usages
2. **Use feature flags** for new features that might affect existing functionality
3. **Follow the feature structure**: `src/features/<feature>/` with components, hooks, api, types, utils
4. **Keep components under 300 LOC** - split if needed
5. **Add tests** for new features (unit tests for components/hooks, integration tests for API)

### When Modifying Existing Code
1. **Preserve existing API contracts** - don't change function signatures without checking all callers
2. **Maintain backward compatibility** when possible
3. **Check for side effects** - search for all imports/usages of modified code
4. **Verify TypeScript types** still compile (`npm run type-check`)
5. **Run linting** before committing (`npm run lint`)

### Critical Areas to Protect
- **Authentication flow** (`src/contexts/`, `src/lib/firebaseClient.ts`)
- **Resume editor** (`src/app/editor/`, `src/components/Editor/`)
- **API services** (`src/lib/services/`)
- **Shared components** (`src/components/Shared/`)
- **Core hooks** (`src/hooks/`)
- **Configuration** (`src/lib/config.ts`)

### Testing Requirements
1. **New features must include tests**
2. **Bug fixes must include regression tests**
3. **Before modifying existing code**, check if tests exist and update them
4. **Run type-check and lint** before suggesting changes

### Code Quality Gates
- All code must pass `npm run type-check`
- All code must pass `npm run lint`
- Components must be under 300 LOC
- No `any` types allowed
- Follow the architecture layering rules

### When Refactoring
1. **Search for all usages** of the code being refactored
2. **Update all callers** in the same change
3. **Maintain the same public API** if possible
4. **Add tests** if they don't exist
5. **Document breaking changes** if API changes are necessary

### Import Rules
- Feature components use their own hooks/services
- Cross-feature shared logic lives in `src/lib/` or `src/components/Shared/`
- Never create circular dependencies

### Error Handling
- Always handle errors gracefully
- Don't break existing error handling patterns
- Maintain consistent error message formats

## Architecture Compliance
- Follow `docs/architecture.md` strictly
- Enforce one-directional dependencies: presentation → application services → domain → infrastructure
- Use typed contracts (TypeScript types, Zod schemas)
- Keep domain logic separate from UI concerns

## Design sysyesms
Design System: Use a minimalist, modern SaaS aesthetic. 
- Spacing: Use consistent 4px/8px (8, 16, 24, 32) spacing. 
- Typography: Sans-serif fonts only (Inter, Geist, or Arial). 
- Visual Noise: Reduce heavy borders and solid background colors. 
- Interactivity: Secondary actions (Delete, AI Assistant) should be hidden until hover.
- Feedback: Use subtle underlines for keyword matching instead of solid red/green blocks.
- Prevent desktop breakage when making mobile changes
- Prevent mobile breakage when making desktop changes
- Provide clear prompting guidelines
- Include testing checklists
- Define safe patterns to follow

## Responsive Design Rules (CRITICAL - Prevent Desktop/Mobile Conflicts)

### Breakpoint Standards
- **Mobile**: `< 768px` (use `sm:` prefix for ≥640px, but mobile-first means base styles are mobile)
- **Tablet**: `768px - 1024px` (use `md:` for ≥768px, `lg:` for ≥1024px)
- **Desktop**: `≥ 1024px` (use `lg:` and `xl:` prefixes)
- **Never use global CSS `@media` queries** - use Tailwind responsive utilities instead

### Mobile-First Approach (MANDATORY)
1. **Base styles = mobile styles** (no prefix)
2. **Desktop overrides use `lg:` prefix** (≥1024px)
3. **Always provide desktop override** when adding mobile styles
4. **Never modify base styles without checking desktop impact**

### When Making Mobile Changes
1. **Before modifying mobile styles:**
   - Search for all usages: `grep -r "className.*lg:" <file>`
   - Check if component has desktop-specific styles
   - Verify desktop breakpoint (≥1024px) won't be affected

2. **Mobile style pattern (REQUIRED):**
   ```tsx
   // ✅ CORRECT - Mobile-first with explicit desktop override
   <div className="
     flex flex-col gap-2        // Mobile (base)
     lg:flex-row lg:gap-4       // Desktop override
     px-4 py-4                  // Mobile padding
     lg:px-8 lg:py-6           // Desktop padding
   ">
   ```

3. **NEVER do this:**
   ```tsx
   // ❌ WRONG - No desktop override
   <div className="flex flex-col gap-2 px-4 py-4">
   
   // ❌ WRONG - Global CSS media query
   @media (max-width: 768px) {
     .my-class { ... }
   }
   
   // ❌ WRONG - Mobile styles without desktop consideration
   <div className="mobile-padding">  // What happens on desktop?
   ```

### When Making Desktop Changes
1. **Before modifying desktop styles:**
   - Check if mobile base styles exist
   - Verify mobile breakpoint (<768px) won't be affected
   - Ensure `lg:` prefixes are used (not `md:` for desktop)

2. **Desktop style pattern (REQUIRED):**
   ```tsx
   // ✅ CORRECT - Desktop changes only affect ≥1024px
   <div className="
     flex flex-col gap-2        // Mobile (preserved)
     lg:flex-row lg:gap-6       // Desktop (modified)
   ">
   ```

3. **NEVER do this:**
   ```tsx
   // ❌ WRONG - Modifying base styles affects mobile
   <div className="flex-row gap-6">  // Breaks mobile!
   
   // ❌ WRONG - Using wrong breakpoint
   <div className="md:flex-row">  // md: is 768px, not desktop
   ```

### Global CSS Rules (AVOID)
- **NEVER add new `@media` queries in `globals.css`**
- **NEVER create mobile-only classes** without desktop equivalents
- **If you must use global CSS**, always add corresponding desktop reset:
  ```css
  @media (max-width: 768px) {
    .mobile-only-class { ... }
  }
  
  @media (min-width: 769px) {
    .mobile-only-class { 
      /* Reset or override for desktop */
    }
  }
  ```

### Component Isolation Rules
1. **Each component is responsible for its own responsive behavior**
2. **Don't rely on parent container breakpoints** - be explicit
3. **Use container queries for component-level responsiveness** when appropriate
4. **Test at breakpoint boundaries**: 767px, 768px, 1023px, 1024px

### Scale/Transform Rules
- **Never use `scale-*` without `lg:` override**
- **Always reset transforms on desktop:**
  ```tsx
  // ✅ CORRECT
  <div className="scale-50 lg:scale-100">
  
  // ❌ WRONG
  <div className="scale-50">  // Affects desktop!
  ```

### Visibility Rules
- **Use `hidden lg:block` for desktop-only elements**
- **Use `block lg:hidden` for mobile-only elements**
- **Never use `display: none` in global CSS** without responsive consideration

### Spacing/Padding Rules
- **Always provide both mobile and desktop spacing:**
  ```tsx
  // ✅ CORRECT
  <div className="px-4 py-4 lg:px-8 lg:py-6">
  
  // ❌ WRONG
  <div className="px-4 py-4">  // No desktop spacing
  ```

### Grid/Flex Rules
- **Mobile: single column, Desktop: multi-column**
- **Always specify both:**
  ```tsx
  // ✅ CORRECT
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 lg:gap-6">
  
  // ❌ WRONG
  <div className="grid grid-cols-2">  // Breaks mobile
  ```

### Testing Checklist (MANDATORY)
Before completing responsive changes:
1. ✅ Test at 375px (mobile)
2. ✅ Test at 768px (tablet boundary)
3. ✅ Test at 1024px (desktop boundary)
4. ✅ Test at 1920px (large desktop)
5. ✅ Verify no horizontal scroll on any breakpoint
6. ✅ Check that desktop layout matches design
7. ✅ Verify mobile layout matches design

### Common Pitfalls to Avoid
1. **Modifying base styles** without checking mobile impact
2. **Using `md:` breakpoint** for desktop (should be `lg:`)
3. **Forgetting desktop overrides** when adding mobile styles
4. **Global CSS media queries** conflicting with Tailwind
5. **Scale transforms** without desktop reset
6. **Fixed positioning** without responsive consideration
7. **Absolute positioning** breaking on different screen sizes

### File-Specific Rules
- **`globals.css`**: Only use for truly global styles, avoid responsive overrides
- **Component files**: Use Tailwind responsive utilities directly
- **Layout components**: Always test both mobile and desktop layouts

## Prompting Best Practices

### How to Prompt for Responsive Changes

#### ✅ GOOD Prompts (Specific & Safe)
```
"Add mobile padding (px-4 py-4) to the header component, 
ensuring desktop keeps existing padding (lg:px-8 lg:py-6)"
```

```
"Make the sidebar hidden on mobile (hidden lg:block) 
without affecting desktop visibility"
```

```
"Change the grid to single column on mobile (grid-cols-1) 
while keeping 2 columns on desktop (lg:grid-cols-2)"
```

#### ❌ BAD Prompts (Vague & Risky)
```
"Fix mobile layout"  // Too vague, might break desktop
```

```
"Make it responsive"  // No specific breakpoints mentioned
```

```
"Update the styles"  // Doesn't specify mobile vs desktop
```

### Prompt Structure Template
When requesting responsive changes, use this structure:

```
[Action] [Component/Element] for [Breakpoint]:
- Mobile (<768px): [specific change]
- Desktop (≥1024px): [specific change or "keep existing"]
- Test at: [specific breakpoints]
```

### Example Good Prompts

1. **Mobile-specific change:**
   ```
   Add mobile menu button to TopNavigationBar:
   - Mobile (<768px): Show hamburger menu (hidden lg:hidden)
   - Desktop (≥1024px): Keep existing desktop menu (lg:flex)
   - Test at: 375px, 768px, 1024px
   ```

2. **Desktop-specific change:**
   ```
   Increase sidebar width on desktop only:
   - Mobile (<768px): Keep existing (no change)
   - Desktop (≥1024px): Change from w-64 to w-80 (lg:w-80)
   - Test at: 768px, 1024px, 1920px
   ```

3. **Both breakpoints:**
   ```
   Update spacing in DashboardLayout:
   - Mobile (<768px): px-4 py-4
   - Desktop (≥1024px): px-8 py-6 (lg:px-8 lg:py-6)
   - Test at: 375px, 768px, 1024px
   ```

### Prompt Safety Keywords
Include these keywords to ensure safety:
- **"without affecting desktop"** - When making mobile changes
- **"without affecting mobile"** - When making desktop changes
- **"preserve existing [mobile/desktop] styles"** - When modifying one breakpoint
- **"test at breakpoints"** - Always include this
- **"use Tailwind responsive utilities"** - Avoid global CSS

### AI Assistant Instructions
When AI makes responsive changes, it should:
1. **Always show both mobile and desktop classes** in the same code block
2. **Explain which breakpoint each class targets**
3. **Mention what was preserved** from existing code
4. **Suggest testing at specific breakpoints**
5. **Warn if global CSS is being modified**

### Code Review Checklist for Responsive Changes
When reviewing responsive code changes:
- [ ] Both mobile and desktop styles are present
- [ ] `lg:` prefixes used for desktop (not `md:`)
- [ ] Base styles are mobile-first
- [ ] No global CSS `@media` queries added
- [ ] Scale/transform has desktop reset
- [ ] Visibility classes are explicit (`hidden lg:block`)
- [ ] Spacing provided for both breakpoints
- [ ] Grid/flex layouts specified for both breakpoints

## Backend Feature Development Rules

### Feature Module Structure (MANDATORY)
When adding new API features, ALWAYS follow this structure:

1. **Create feature module directory:**
   ```
   backend/app/features/<feature_name>/
     ├── __init__.py          # Router export
     ├── routes.py            # API endpoints
     ├── services.py          # Business logic (optional)
     ├── models.py            # Feature-specific models (optional)
     └── types.py             # Type definitions (optional)
   ```

2. **Router structure in routes.py:**
   ```python
   from fastapi import APIRouter, Depends
   from app.core.service_factory import get_service_name
   
   router = APIRouter(prefix="/api/feature-name", tags=["feature_name"])
   
   @router.get("/endpoint")
   async def my_endpoint(service: ServiceType = Depends(get_service_name)):
       # Implementation
       pass
   ```

3. **Export router in __init__.py:**
   ```python
   from app.features.feature_name.routes import router
   __all__ = ["router"]
   ```

4. **Register in main.py:**
   ```python
   from app.features.feature_name import router as feature_router
   app.include_router(feature_router)
   ```

### Backward Compatibility (CRITICAL)
- **NEVER delete old API files** (`app/api/` directory)
- Always maintain backward compatibility by re-exporting router:
  ```python
  # app/api/old_file.py
  """Old API file - kept for backward compatibility.
  
  NOTE: Endpoints moved to app/features/new_feature/routes.py
  This file re-exports the router for backward compatibility.
  """
  from app.features.new_feature.routes import router
  ```
- Old router registrations in `main.py` should remain for compatibility

### Dependency Injection (MANDATORY)
- **ALWAYS use Service Factory pattern** for service creation
- Services MUST be injected via `app/core/service_factory.py`
- NEVER use global singletons directly in endpoints
- Example:
  ```python
  # ✅ CORRECT
  from app.core.service_factory import get_enhanced_ats_service
  @router.post("/endpoint")
  async def endpoint(service: EnhancedATSChecker = Depends(get_enhanced_ats_service)):
      result = service.calculate_score(...)
  
  # ❌ WRONG
  from app.core.dependencies import enhanced_ats_checker  # Global singleton
  @router.post("/endpoint")
  async def endpoint():
      result = enhanced_ats_checker.calculate_score(...)
  ```

### Testing Requirements (MANDATORY)
- **ALWAYS run regression tests** before completing feature addition:
  ```bash
  cd backend && make test-regression
  ```
- All 17 regression tests MUST pass
- New features should include unit tests when possible
- Test files should be in `backend/tests/features/<feature_name>/`

### Code Organization Rules
- **Maximum file size:** 500 lines per file
  - If exceeding, split into sub-modules
- **Maximum function size:** 50 lines per function
  - If exceeding, extract helper functions
- **Maximum endpoint file:** 20 endpoints per routes.py
  - If exceeding, split into multiple route files

### Import Rules
- **Feature modules MUST NOT import each other** (no circular dependencies)
- Shared logic goes in `app/lib/` or `app/core/`
- Cross-feature communication via service layer only
- Use absolute imports: `from app.features.x import y`

### Error Handling
- **ALL endpoints MUST have try-except blocks**
- Consistent error response format:
  ```python
  {
      "success": False,
      "error": "Error message",
      "details": {}  # Optional
  }
  ```
- Always log errors: `logger.error(f"Error: {e}", exc_info=True)`

### Documentation Requirements
- **ALL endpoints MUST have docstrings**
- Include request/response examples in docstrings
- Document required dependencies and services
- Add type hints for all function parameters and returns

### Step-by-Step Feature Addition Process

1. **Create feature module structure:**
   ```bash
   mkdir -p backend/app/features/new_feature
   touch backend/app/features/new_feature/__init__.py
   touch backend/app/features/new_feature/routes.py
   ```

2. **Implement routes.py with endpoints**

3. **Export router in __init__.py**

4. **Register in main.py:**
   ```python
   from app.features.new_feature import router as new_feature_router
   app.include_router(new_feature_router)
   ```

5. **Update old API file (if exists) for backward compatibility:**
   ```python
   from app.features.new_feature.routes import router
   ```

6. **Run regression tests:**
   ```bash
   cd backend && make test-regression
   ```

7. **Follow the test checklist:**
   - See `backend/tests/NEW_FEATURE_CHECKLIST.md` for complete checklist
   - Minimum: Regression tests + Lint + Manual test
   - Recommended: + Unit tests for new feature

8. **Verify all tests pass before completing**

### Service Factory Pattern
- New services MUST be added to `app/core/service_factory.py`
- Create factory method: `create_service_name() -> ServiceType`
- Create dependency function: `get_service_name() -> ServiceType`
- Use dependency injection in endpoints

### Code Quality Gates
- All code must pass `pytest tests/regression/ -v`
- All code must pass type checking (if mypy configured)
- All endpoints must have error handling
- All services must be testable (dependency injection)
- No global mutable state
- No circular dependencies

### When Modifying Existing Features
1. **Search for all usages** before modifying:
   ```bash
   grep -r "function_name" backend/app/
   ```
2. **Check feature boundaries** - don't break other features
3. **Update tests** if behavior changes
4. **Maintain API contracts** - don't change response formats without versioning
5. **Run regression tests** after changes

### Critical Areas to Protect
- **Service Factory** (`app/core/service_factory.py`) - never bypass
- **Database models** (`app/models/`) - changes affect all features
- **Core dependencies** (`app/core/`) - shared infrastructure
- **Existing feature modules** - maintain boundaries










