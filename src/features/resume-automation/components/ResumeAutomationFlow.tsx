"use client"

import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { useRouter } from 'next/navigation'

import { useSavedJobs } from '@/features/jobs/hooks/useSavedJobs'
import { SavedJobsList } from '@/features/jobs/components/SavedJobsList'
import { AutoGenerateButton } from './AutoGenerateButton'
import { JobSelectionModal } from './JobSelectionModal'
import { ResumeSelectionModal } from './ResumeSelectionModal'
import { GenerationProgress } from './GenerationProgress'
import { GeneratedResumePreview } from './GeneratedResumePreview'
import { ATSScoreCard } from './ATSScoreCard'
import { OptimizationSuggestions } from './OptimizationSuggestions'
import { useResumeGeneration } from '../hooks/useResumeGeneration'
import { fetchUserResumes } from '../api/resumeAutomation'
import type { AutoGenerateResponse } from '../types'

interface ResumeOption {
  id: number
  name: string
  title?: string | null
  summary?: string | null
  updated_at?: string | null
}

type Stage = 'idle' | 'progress' | 'completed'

interface ResumeAutomationFlowProps {
  openSignal?: number
  hideJobList?: boolean
  hideHeader?: boolean
}

export function ResumeAutomationFlow({
  openSignal,
  hideJobList = false,
  hideHeader = false,
}: ResumeAutomationFlowProps) {
  const router = useRouter()
  const [stage, setStage] = useState<Stage>('idle')
  const [jobModalOpen, setJobModalOpen] = useState(false)
  const [resumeModalOpen, setResumeModalOpen] = useState(false)
  const [selectedJob, setSelectedJob] = useState<number | null>(null)
  const [selectedJobTitle, setSelectedJobTitle] = useState<string>('')
  const [selectedJobDescription, setSelectedJobDescription] = useState<string>('')
  const [resumeOptions, setResumeOptions] = useState<ResumeOption[]>([])
  const [resumeLoading, setResumeLoading] = useState(false)
  const [resumeError, setResumeError] = useState<string | null>(null)
  const [generationResult, setGenerationResult] = useState<AutoGenerateResponse | null>(null)

  const generation = useResumeGeneration()
  const { jobs, loading: jobsLoading, error: jobsError, refresh: refreshJobs } = useSavedJobs()
  const timersRef = useRef<ReturnType<typeof setTimeout>[]>([])

  const openJobModal = useCallback(() => {
    setSelectedJob(null)
    setSelectedJobTitle('')
    setGenerationResult(null)
    generation.reset()
    setStage('idle')
    setJobModalOpen(true)
  }, [generation])

  const previousSignalRef = useRef<number | undefined>(undefined)

  useEffect(() => {
    if (typeof openSignal === 'number' && openSignal !== previousSignalRef.current) {
      previousSignalRef.current = openSignal
      openJobModal()
    }
  }, [openSignal, openJobModal])

  const cleanupTimers = () => {
    timersRef.current.forEach((timer) => clearTimeout(timer))
    timersRef.current = []
  }

  const loadResumes = useCallback(async () => {
    setResumeLoading(true)
    setResumeError(null)
    try {
      const list = await fetchUserResumes()
      setResumeOptions(list)
    } catch (error) {
      setResumeError(error instanceof Error ? error.message : 'Failed to load resumes')
    } finally {
      setResumeLoading(false)
    }
  }, [])

  useEffect(() => cleanupTimers, [])

  const handleJobSelected = useCallback(
    (job: { id: number; title: string; description?: string }) => {
      setSelectedJob(job.id)
      setSelectedJobTitle(job.title)
      setSelectedJobDescription(job.description || '')
      setJobModalOpen(false)
      setResumeModalOpen(true)
      void loadResumes()
    },
    [loadResumes]
  )

  const handleResumeConfirm = useCallback(
    async (resumeIds: number[]) => {
      if (!selectedJob) {
        setGenerationResult(null)
        setStage('idle')
        return
      }
      const safeIds = resumeIds.map((id) => Number(id)).filter((id) => Number.isInteger(id))
      if (safeIds.length === 0) {
        setGenerationResult(null)
        setStage('idle')
        return
      }
      setResumeModalOpen(false)
      setStage('progress')
      generation.reset()

      // Simulated step progression for UX feedback
      cleanupTimers()
      const scheduleStep = (stepId: string, delay: number) => {
        const timer = setTimeout(() => {
          generation.advanceStep(stepId)
        }, delay)
        timersRef.current.push(timer)
      }
      scheduleStep('evaluate-resumes', 600)
      scheduleStep('optimize-content', 1400)
      scheduleStep('calculate-score', 2200)

      try {
        const result = await generation.generate({
          jobId: selectedJob,
          sourceResumeIds: safeIds,
        })
        cleanupTimers()
        setGenerationResult(result)
        setStage('completed')
        try {
          localStorage.setItem(
            'autoGeneratedATS',
            JSON.stringify({
              atsScore: result.ats_score,
              insights: result.insights,
              generatedAt: new Date().toISOString(),
            })
          )
        } catch {
          // ignore storage errors
        }
      } catch {
        cleanupTimers()
        setStage('idle')
        setGenerationResult(null)
      }
    },
    [generation, selectedJob]
  )

  const handleOpenEditor = useCallback(() => {
    if (!generationResult) {
      console.error('Cannot open editor: generationResult is null')
      return
    }
    
    try {
      const resumeId = generationResult.resume.id
      const versionId = generationResult.version.id
      
      if (!resumeId || !versionId) {
        console.error('Missing resume ID or version ID', { resumeId, versionId })
        return
      }
      
      const params = new URLSearchParams({
        resumeId: String(resumeId),
        resumeVersionId: String(versionId),
        autoGenerated: '1',
      })
      
      if (selectedJob) {
        params.set('jdId', String(selectedJob))
        if (selectedJobDescription && typeof window !== 'undefined') {
          localStorage.setItem('deepLinkedJD', selectedJobDescription)
          localStorage.setItem('activeJobDescriptionId', String(selectedJob))
        }
      }
      
      const url = `/editor?${params.toString()}`
      console.log('Navigating to editor:', url)
      
      router.push(url).catch((error) => {
        console.error('Router push failed, using window.location:', error)
        window.location.href = url
      })
    } catch (error) {
      console.error('Error opening editor:', error)
      alert('Failed to open editor. Please try again.')
    }
  }, [generationResult, router, selectedJob, selectedJobDescription])

  const summaryCard = useMemo(() => {
    if (!generationResult) return null
    return (
      <div className="grid gap-6 lg:grid-cols-[minmax(0,1.2fr)_minmax(0,0.8fr)]">
        <GeneratedResumePreview
          resume={generationResult.resume}
          atsScore={generationResult.ats_score}
          insights={generationResult.insights}
          onOpenEditor={handleOpenEditor}
        />
        <div className="space-y-6">
          <ATSScoreCard score={generationResult.ats_score} />
          <OptimizationSuggestions result={generationResult} />
        </div>
      </div>
    )
  }, [generationResult, handleOpenEditor])

  const handleRequestResumeUpload = useCallback(() => {
    setResumeModalOpen(false)
    router.push('/editor?upload=true&source=resume-automation')
  }, [router])

  const handleRequestJobParse = useCallback(() => {
    setJobModalOpen(false)
    router.push('/editor?view=jobs&source=resume-automation')
  }, [router])

  return (
    <div className="space-y-8">
      {!hideHeader && (
        <div className="flex flex-col gap-4 rounded-3xl border border-slate-200 bg-white p-6 shadow-sm lg:flex-row lg:items-center lg:justify-between">
          <div>
            <p className="text-xs font-semibold uppercase tracking-[0.4em] text-slate-400">
              Automation
            </p>
            <h2 className="text-lg font-semibold text-slate-900">
              Generate an optimized resume for a saved job
            </h2>
            <p className="text-sm text-slate-500">
              We analyze your saved resumes, combine their strongest sections, and tune everything for ATS.
            </p>
          </div>
          <AutoGenerateButton onClick={openJobModal} />
        </div>
      )}

      {stage === 'progress' && (
        <GenerationProgress steps={generation.steps} />
      )}

      {stage === 'completed' && summaryCard}

      {stage === 'idle' && generation.error && (
        <div className="rounded-2xl border border-rose-200 bg-rose-50 p-4 text-sm text-rose-600">
          {generation.error}
        </div>
      )}

      {stage === 'idle' && !generationResult && !hideJobList && (
        <div>
          <header className="mb-4 flex items-center justify-between">
            <h3 className="text-sm font-semibold uppercase tracking-[0.3em] text-slate-400">
              Saved jobs
            </h3>
            <button
              type="button"
              onClick={refreshJobs}
              className="text-xs font-semibold text-indigo-600 hover:text-indigo-500"
            >
              Refresh
            </button>
          </header>
          <SavedJobsList
            jobs={jobs}
            loading={jobsLoading}
            error={jobsError}
            onSelect={(job) => handleJobSelected(job)}
          />
        </div>
      )}

      <JobSelectionModal
        jobs={jobs}
        isOpen={jobModalOpen}
        loading={jobsLoading}
        error={jobsError || null}
        onClose={() => setJobModalOpen(false)}
        onSelect={handleJobSelected}
        onRefresh={refreshJobs}
        onAddJob={handleRequestJobParse}
      />

      <ResumeSelectionModal
        resumes={resumeOptions}
        isOpen={resumeModalOpen}
        loading={resumeLoading}
        error={resumeError}
        onClose={() => setResumeModalOpen(false)}
        onConfirm={handleResumeConfirm}
        onRefresh={loadResumes}
        onUploadResume={handleRequestResumeUpload}
      />

      {selectedJob && stage !== 'completed' && (
        <div className="text-xs text-slate-400">
          Target job: {selectedJobTitle}
        </div>
      )}
    </div>
  )
}

